# 状态管理

<cite>
**本文引用的文件**
- [Temperature_my.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my.java)
- [Temperature_my_2.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_2.java)
- [Temperature_my_3.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_3.java)
- [Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java)
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java)
- [Spark_Integer_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_teacher.java)
- [Dic_my.java](file://_06_flink/src/main/java/_08_richFunction/_09_Dic_my.java)
- [KeyedProcessFunction.java](file://_06_flink/src/main/java/_08_richFunction/_04_KeyedProcessFunction.java)
- [Alert.java](file://_06_flink/src/main/java/_08_richFunction/_04_Alert.java)
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java)
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java)
- [KafkaFlinkKafkaExactlyOnce.java](file://_06_flink/src/main/java/_17_UV/_06_KafkaFlinkKafkaExactlyOnce.java)
- [BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java)
- [SensorReading.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorReading.java)
- [SensorSource.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorSource.java)
- [flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom)
- [flink-statebackend-rocksdb_2.12-1.13.0.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.12/1.13.0/flink-statebackend-rocksdb_2.12-1.13.0.pom)
- [flink-statebackend-rocksdb_2.11-1.13.1.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.11/1.13.1/flink-statebackend-rocksdb_2.11-1.13.1.pom)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构总览](#架构总览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考虑](#性能考虑)
8. [故障排查指南](#故障排查指南)
9. [结论](#结论)
10. [附录](#附录)

## 简介
本技术文档围绕Flink状态管理展开，系统阐述Keyed State与Operator State的区别与使用场景，详解RichFunction、KeyedProcessFunction等状态函数的使用方法，并结合温度监控、字典查询、告警系统等实际案例，展示状态在流处理中的落地实践。同时，文档覆盖状态后端（State Backend）的选择与配置、状态持久化、检查点机制与状态恢复的实现细节，并提供性能优化与内存管理的最佳实践。

## 项目结构
本仓库中与Flink状态管理密切相关的代码主要集中在以下模块：
- _06_flink/src/main/java/_08_richFunction：包含KeyedProcessFunction、RichFunction、定时器与状态使用的大量示例
- _06_flink/src/main/java/_17_UV：包含检查点、Operator State与Exactly-once语义的示例
- _06_flink_wu/src/main/java/com/atguigu/chatper09：包含状态后端配置与外部化检查点的示例
- com/atguigu/utils：包含传感器数据模型与数据源，用于温度监控等场景

```mermaid
graph TB
subgraph "状态管理示例"
KPF["KeyedProcessFunction 示例<br/>温度监控/字典查询/定时器"]
RICH["RichFunction 示例<br/>统计/幂等写入"]
CKPT["检查点与Operator State 示例"]
STATEBACK["状态后端与外部化检查点"]
end
subgraph "工具与数据源"
SR["传感器数据模型"]
SS["传感器数据源"]
end
KPF --> SR
KPF --> SS
CKPT --> KPF
STATEBACK --> KPF
```

**图表来源**
- [Temperature_my.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my.java#L1-L37)
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)
- [BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java#L29-L56)
- [SensorReading.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorReading.java#L1-L23)
- [SensorSource.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorSource.java#L1-L31)

**章节来源**
- [Temperature_my.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my.java#L1-L37)
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)
- [BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java#L29-L56)
- [SensorReading.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorReading.java#L1-L23)
- [SensorSource.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorSource.java#L1-L31)

## 核心组件
- Keyed State（键控状态）：按key划分的状态，KeyedProcessFunction在每个key上维护独立的状态，适合需要基于key进行聚合或上下文记忆的场景
- Operator State（算子状态）：在算子实例级别维护的状态，适用于广播、列表状态等，典型用法为Source的偏移量记录
- RichFunction：在FlatMap/Map等基础上扩展了生命周期回调（open/close），并提供运行时上下文，便于声明和使用状态
- KeyedProcessFunction：功能最强的状态函数，支持Keyed State、定时器（processing time/event time）、侧输出等能力
- 检查点（Checkpoint）：周期性持久化状态，保障容错与一致性；配合状态后端实现本地与远端存储

**章节来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [KeyedProcessFunction.java](file://_06_flink/src/main/java/_08_richFunction/_04_KeyedProcessFunction.java#L1-L63)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [KafkaFlinkKafkaExactlyOnce.java](file://_06_flink/src/main/java/_17_UV/_06_KafkaFlinkKafkaExactlyOnce.java#L32-L105)

## 架构总览
下图展示了状态管理在Flink作业中的整体交互：数据源产生事件，经过KeyBy进入KeyedProcessFunction，利用Keyed State与定时器完成状态维护与触发逻辑；同时，检查点机制定期持久化状态，确保故障恢复时能从最近一次检查点恢复。

```mermaid
sequenceDiagram
participant SRC as "数据源"
participant KEYBY as "KeyBy"
participant KPF as "KeyedProcessFunction"
participant TIMER as "定时器服务"
participant CP as "检查点/状态后端"
SRC->>KEYBY : "事件流入"
KEYBY->>KPF : "按key分发事件"
KPF->>KPF : "读取/更新Keyed State"
KPF->>TIMER : "注册/删除定时器"
TIMER-->>KPF : "定时器触发回调"
KPF->>CP : "周期性快照状态"
CP-->>KPF : "恢复状态故障恢复"
```

**图表来源**
- [Temperature_my.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my.java#L1-L37)
- [Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java#L1-L94)
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)

## 详细组件分析

### Keyed State与Operator State的区别与使用场景
- Keyed State：按key隔离，适合“每key一份”的状态，如温度阈值、窗口聚合中间结果、字典映射等
- Operator State：在算子实例级别，适合“全局”或“分片”的状态，如Source的偏移量列表状态

```mermaid
classDiagram
class KeyedProcessFunction {
+processElement(...)
+onTimer(...)
}
class RichFunction {
+open(...)
+close()
}
class SourceOperatorState {
+initializeState(...)
+snapshotState(...)
}
KeyedProcessFunction --> RichFunction : "继承"
SourceOperatorState --> RichFunction : "实现 CheckpointedFunction"
```

**图表来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)

**章节来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)

### RichFunction与KeyedProcessFunction的使用
- RichFunction：通过open初始化状态描述符，使用运行时上下文获取状态句柄
- KeyedProcessFunction：在processElement中读取/更新Keyed State，必要时注册定时器；在onTimer中处理定时触发逻辑

```mermaid
sequenceDiagram
participant ENV as "执行环境"
participant SRC as "SourceFunction"
participant MAP as "Map/KeyBy"
participant KPF as "KeyedProcessFunction"
participant RT as "运行时上下文"
ENV->>SRC : "创建Source"
SRC-->>ENV : "emit事件"
ENV->>MAP : "KeyBy分组"
MAP->>KPF : "事件分发"
KPF->>RT : "获取状态描述符"
KPF->>KPF : "读取/更新Keyed State"
KPF->>KPF : "注册/删除定时器"
KPF-->>ENV : "输出结果"
```

**图表来源**
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)
- [Spark_Integer_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_teacher.java#L1-L36)
- [KeyedProcessFunction.java](file://_06_flink/src/main/java/_08_richFunction/_04_KeyedProcessFunction.java#L1-L63)

**章节来源**
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)
- [Spark_Integer_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_teacher.java#L1-L36)
- [KeyedProcessFunction.java](file://_06_flink/src/main/java/_08_richFunction/_04_KeyedProcessFunction.java#L1-L63)

### 温度监控与告警系统（Keyed State + 定时器）
- 场景目标：检测同一传感器键控下连续1秒温度上升，若满足条件则注册1秒后触发的报警定时器；若在定时器触发前出现温度下降，则取消定时器
- 关键状态：
  - 上一次温度值（ValueState<Double>）
  - 报警定时器时间戳（ValueState<Long>）

```mermaid
flowchart TD
Start(["事件到达"]) --> LoadPrev["读取上次温度与定时器时间戳"]
LoadPrev --> HasPrev{"是否存在上次温度？"}
HasPrev -- 否 --> WaitNext["等待下一条数据"]
HasPrev -- 是 --> Compare["比较当前温度与上次温度"]
Compare --> Rising{"温度上升且无报警定时器？"}
Rising -- 是 --> RegTimer["注册1秒后定时器并保存时间戳"]
Rising -- 否 --> Falling{"温度下降且存在报警定时器？"}
Falling -- 是 --> DelTimer["删除定时器并清空时间戳"]
Falling -- 否 --> End(["结束"])
RegTimer --> End
DelTimer --> End
WaitNext --> End
```

**图表来源**
- [Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java#L1-L94)
- [Temperature_my_2.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_2.java#L70-L99)
- [Temperature_my_3.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_3.java#L68-L102)
- [SensorReading.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorReading.java#L1-L23)
- [SensorSource.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorSource.java#L1-L31)

**章节来源**
- [Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java#L1-L94)
- [Temperature_my_2.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_2.java#L70-L99)
- [Temperature_my_3.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my_3.java#L68-L102)
- [SensorReading.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorReading.java#L1-L23)
- [SensorSource.java](file://_06_flink/src/main/java/com/atguigu/utils/SensorSource.java#L1-L31)

### 字典查询（Keyed State MapState）
- 场景目标：对每个用户访问的URL进行计数，使用MapState维护每个用户的URL计数
- 关键状态：MapState<String, Integer>，键为URL，值为计数

```mermaid
sequenceDiagram
participant SRC as "数据源"
participant KPF as "KeyedProcessFunction"
participant MS as "MapState"
SRC->>KPF : "用户访问事件"
KPF->>MS : "读取URL计数"
KPF->>MS : "计数+1并写回"
KPF-->>SRC : "输出统计结果"
```

**图表来源**
- [Dic_my.java](file://_06_flink/src/main/java/_08_richFunction/_09_Dic_my.java#L1-L50)

**章节来源**
- [Dic_my.java](file://_06_flink/src/main/java/_08_richFunction/_09_Dic_my.java#L1-L50)

### 统计聚合与定时输出（ValueState + 定时器）
- 场景目标：对整型序列进行滚动统计（最小值、最大值、总和、计数、平均值），定时器周期性输出统计结果
- 关键状态：ValueState<IntStatistic>，保存聚合中间结果；ValueState<Boolean>用于防重复定时器注册

```mermaid
sequenceDiagram
participant SRC as "数据源"
participant KPF as "KeyedProcessFunction"
participant VS as "ValueState"
participant TIMER as "定时器服务"
SRC->>KPF : "整型数据"
KPF->>VS : "读取/更新聚合状态"
KPF->>TIMER : "首次到达注册定时器"
TIMER-->>KPF : "定时器触发"
KPF->>VS : "清空定时器标志"
KPF-->>SRC : "输出统计结果"
```

**图表来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)

**章节来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)

### 检查点与Operator State（Source偏移量）
- 场景目标：Source通过ListState记录已消费偏移量，在故障恢复时从上次检查点恢复偏移量继续消费，实现Exactly-once
- 关键接口：CheckpointedFunction.initializeState、snapshotState

```mermaid
sequenceDiagram
participant SRC as "SourceFunction"
participant Ctx as "FunctionInitializationContext"
participant S as "FunctionSnapshotContext"
participant LS as "ListState<Long>"
SRC->>Ctx : "initializeState()"
Ctx-->>SRC : "获取Operator State"
SRC->>LS : "读取偏移量"
loop "运行期"
SRC->>S : "snapshotState() 触发"
S-->>SRC : "保存偏移量"
end
```

**图表来源**
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [KafkaFlinkKafkaExactlyOnce.java](file://_06_flink/src/main/java/_17_UV/_06_KafkaFlinkKafkaExactlyOnce.java#L32-L105)

**章节来源**
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [KafkaFlinkKafkaExactlyOnce.java](file://_06_flink/src/main/java/_17_UV/_06_KafkaFlinkKafkaExactlyOnce.java#L32-L105)

### 状态后端选择与配置
- MemoryStateBackend：内存态，速度快但不可用于生产；适合本地测试
- FsStateBackend：文件系统态，适合小规模状态与简单部署
- RocksDBStateBackend：磁盘+LSM树，适合大规模状态与高吞吐场景；需引入rocksdb模块

```mermaid
graph LR
MEM["MemoryStateBackend"] --> 生产环境["不推荐用于生产"]
FS["FsStateBackend"] --> 小规模["小规模/简单部署"]
ROCKS["RocksDBStateBackend"] --> 大规模["大规模/高吞吐"]
subgraph "模块依赖"
POM1["flink-state-backends-1.13.0.pom"]
POM2["flink-statebackend-rocksdb_2.12-1.13.0.pom"]
POM3["flink-statebackend-rocksdb_2.11-1.13.1.pom"]
end
ROCKS --- POM1
POM1 --- POM2
POM1 --- POM3
```

**图表来源**
- [flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom#L1-L44)
- [flink-statebackend-rocksdb_2.12-1.13.0.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.12/1.13.0/flink-statebackend-rocksdb_2.12-1.13.0.pom#L1-L33)
- [flink-statebackend-rocksdb_2.11-1.13.1.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.11/1.13.1/flink-statebackend-rocksdb_2.11-1.13.1.pom#L1-L33)

**章节来源**
- [flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom#L1-L44)
- [flink-statebackend-rocksdb_2.12-1.13.0.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.12/1.13.0/flink-statebackend-rocksdb_2.12-1.13.0.pom#L1-L33)
- [flink-statebackend-rocksdb_2.11-1.13.1.pom](file://org/apache/flink/flink-statebackend-rocksdb_2.11/1.13.1/flink-statebackend-rocksdb_2.11-1.13.1.pom#L1-L33)

### 状态持久化、检查点与恢复
- 检查点配置：启用周期性检查点、设置模式（精确一次）、超时与并发策略、外部化检查点保留策略
- 状态恢复：重启后从最近检查点恢复Keyed State与Operator State

```mermaid
sequenceDiagram
participant ENV as "执行环境"
participant CFG as "CheckpointConfig"
participant BK as "状态后端"
participant CP as "检查点存储"
ENV->>CFG : "enableCheckpointing(...)"
ENV->>CFG : "设置模式/超时/并发/外部化"
ENV->>BK : "setStateBackend(...)"
BK->>CP : "持久化状态快照"
ENV-->>ENV : "故障恢复时加载最近检查点"
```

**图表来源**
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)
- [BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java#L29-L56)

**章节来源**
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)
- [BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java#L29-L56)

## 依赖关系分析
- 状态函数依赖运行时上下文获取状态描述符，Keyed State通过ValueState/MapState等类型声明
- 检查点依赖CheckpointedFunction接口与状态后端，Operator State通过OperatorStateStore访问
- 状态后端模块通过父POM聚合，RocksDB子模块提供磁盘态实现

```mermaid
graph TB
KPF["KeyedProcessFunction"] --> VS["ValueState/MapState"]
KPF --> TIMER["定时器服务"]
SRC["SourceFunction"] --> OPS["OperatorState(ListState)"]
SRC --> CKPT["CheckpointedFunction"]
ENV["执行环境"] --> SB["StateBackend"]
SB --> MEM
SB --> FS
SB --> ROCKS["RocksDBStateBackend"]
```

**图表来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom#L1-L44)

**章节来源**
- [Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom#L1-L44)

## 性能考虑
- 状态大小与序列化：优先使用紧凑类型与高效序列化，避免大对象频繁更新
- 定时器数量控制：合理使用定时器，避免过多定时器导致调度开销增大
- 检查点间隔与超时：根据数据速率与状态大小调整检查点间隔与超时，平衡吞吐与恢复时间
- 状态后端选择：小状态可用FsStateBackend，大状态建议RocksDBStateBackend并结合外部化检查点
- RocksDB调优：结合内存与磁盘I/O特性，调整压缩、缓存与写放大策略（参考调优示例）

[本节为通用指导，无需列出具体文件来源]

## 故障排查指南
- 检查点未生效：确认是否启用检查点、状态后端是否正确设置、检查点存储路径是否可达
- 状态恢复异常：核对状态描述符名称与类型一致性，确保恢复时签名一致
- 定时器未触发：检查定时器注册与删除逻辑，确认Keyed State在触发时仍可访问
- Operator State丢失：确认实现CheckpointedFunction并在initializeState中正确读取ListState

**章节来源**
- [CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)
- [SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)
- [Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java#L1-L94)

## 结论
Flink状态管理通过Keyed State与Operator State分别满足“每key一份”与“算子级”的状态需求，结合KeyedProcessFunction与RichFunction可灵活实现复杂业务逻辑。借助检查点与状态后端，系统可在故障后可靠恢复。针对不同场景选择合适的状态后端与检查点策略，并遵循性能优化与内存管理最佳实践，可显著提升系统的稳定性与吞吐表现。

## 附录
- 实战案例清单
  - 温度监控与告警：[Temperature_my.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_my.java#L1-L37)、[Temperature_teacher.java](file://_06_flink/src/main/java/_08_richFunction/_10_Temperature_teacher.java#L1-L94)
  - 字典查询与计数：[Dic_my.java](file://_06_flink/src/main/java/_08_richFunction/_09_Dic_my.java#L1-L50)
  - 统计聚合与定时输出：[Spark_Boolean.java](file://_06_flink/src/main/java/_08_richFunction/_07_Spark_Boolean.java#L1-L147)、[Spark_Integer_my.java](file://_06_flink/src/main/java/_08_richFunction/_08_Spark_Integer_my.java#L1-L33)
  - 检查点与Exactly-once：[CheckPoint.java](file://_06_flink/src/main/java/_17_UV/_03_CheckPoint.java#L1-L27)、[SaveCheckPoint.java](file://_06_flink/src/main/java/_17_UV/_05_SaveCheckPoint.java#L1-L98)、[KafkaFlinkKafkaExactlyOnce.java](file://_06_flink/src/main/java/_17_UV/_06_KafkaFlinkKafkaExactlyOnce.java#L32-L105)
  - 状态后端与外部化检查点：[BufferingSinkExample.java](file://_06_flink_wu/src/main/java/com/atguigu/chatper09/BufferingSinkExample.java#L29-L56)、[flink-state-backends-1.13.0.pom](file://org/apache/flink/flink-state-backends/1.13.0/flink-state-backends-1.13.0.pom#L1-L44)